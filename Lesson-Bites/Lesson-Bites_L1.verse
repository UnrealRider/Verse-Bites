using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }

# 名称
# 版本
# 授权声明

# ═════════════════════════════════════════════════════════════════════════════
#   Lesson 00 – 开始学习之前
# ────────────────────────────────────────────────────────────────────────────
<# 
- 学习 Verse 前必须对 UEFN 有基础的使用与理解
    - 推荐的 UEFN Youtube 内容作者
        - @GraemeBull (新手到入门)
        - @howtwoboss (进阶)
- 安装 VS Code
- Verse 修改的差异与便利性
- 系统常态错误
- 安装 Verse Bites
- 建立 MyBites
- 经常性错误问题
    - 删除某个 Verse 文件导致编译错误
#>
# ═════════════════════════════════════════════════════════════════════════════


# ═════════════════════════════════════════════════════════════════════════════
#   Lesson 01 – 建立第一个 Verse Device
# ────────────────────────────────────────────────────────────────────────────
# bites_a_device
bites_a_device := class(creative_device):
# `bites_a_device` 会作为 UEFN 中显示的装置名称，你可以随意修改
# `bites_a_device := class(creative_device):` 这是一个 Class, 你现在只需要知道: 这是一个 Class 这件事

    # OnBegin 这段语法会在开始游戏时执行一次
    # `OnBegin<override>()<suspends>:void =` 这是一个 Function, 你现在只需要知道: 这是一个 Function 这件事
    OnBegin<override>()<suspends>:void =
        # Print ("文字") 会把括号中的文字显示在画面左上角
        Print ("这是一个 Verse Device，现在它只会显示这行文字！")

# ── TRY IT YOURSELF ──────────────────────────────────────────────────────────
# 1. 复制整个 bites_a_device 类到 MyBites.verse 中
# 2. 把类名称 `bites_a_device` 改成你喜欢的命名，例如 my_first_device
# 3. Build Verse
# 4. 在 UEFN 的项目 Content Browser 下找到项目文件夹下的 Verse 文件夹，将 my_first_device 放到场景中
# 5. 启动游戏会话并查看结果
# ═════════════════════════════════════════════════════════════════════════════



# ═════════════════════════════════════════════════════════════════════════════
#   Lesson 02 – 让 Verse Device 与 UEFN 按钮互动
# ────────────────────────────────────────────────────────────────────────────
#   目标：当玩家按下 UEFN Button Device 时，在画面显示提示文字
#   在这段学习中，你只需要稍微知道运行的流程即可，不需要立即对所有内容进行了解
# bites_a_button_device
bites_a_button_device := class(creative_device):

    # 这段语法可以在 Verse Device 上实现与 UEFN Device 关联的接口
    @editable Button : button_device = button_device{}
 
    # OnBegin
    OnBegin<override>()<suspends>:void =
        # 当游戏开始时，使用 Subscribe 来订阅玩家按下 Button 的事件，这个事件会执行 `OnButton` 
        Button.InteractedWithEvent.Subscribe( OnButton )

    # 每当玩家按下按钮，就会调用这个 OnButton
    OnButton(Agent:agent):void =
        Print ("你按下了按钮！")

    # `OnButton(Agent:agent):void =` 这也是一个 Function, 那么你将会有以下的问题:
        # 这里的 `Agent:agent` 是什么? 在 Lesson 18 之前，你先不需要理解，只需要完整的 Copy 贴上使用即可
        # 如何识别 Class 与 Function? 在 Lesson 19 之前，你只要识别带有 `class` 的就是 Class，带有 void 的就是 Function


# ── TRY IT YOURSELF ──────────────────────────────────────────────────────────
# 1. 复制整个 bites_a_button_device 类到 MyBites.verse 中
# 2. Build Verse 后将设备放到 UEFN 的场景中
# 3. 选择你的 Verse Device ，然后细节面板将 Button 选项关联一个 UEFN Button Device
# 4. 进入游戏并点击按钮，查看画面上是否出现文字
# 5. 想改别的讯息？直接改 Print 里的句子！
# ═════════════════════════════════════════════════════════════════════════════



# ═════════════════════════════════════════════════════════════════════════════
#   Lesson 03 – Comments
# ────────────────────────────────────────────────────────────────────────────
#   目标：认识两种常用的注释写法
# bites_comments
bites_comments := class(creative_device):

    # OnBegin
    OnBegin<override>()<suspends>:void =
        # 1. 行内注释   以 `#` 开头，到行尾结束
        # 下面演示行内注释：代码右侧用 # 写说明
        Print ("Comments 1")   # 这是一段行内注释

        # 注释放在代码上一行, 这行注释不会影响下一行代码
        Print ("Comments 2")

        # ❌ 注释结束后再写代码是无效的示范，会被当成注释
        # Print("Comments 3")

        # 2. 区块注释   以 `<#` 开头，`#>` 结束，可跨多行
        # 以下三行被 `<# #>` 区块注释包围，游戏中不会执行
        <# 
        Print("Comments 4")
        Print("Comments 5")
        #>

        Print ("Comments 6")   # 最终只会在游戏里看到 1、2、6 三行

# ── TRY IT YOURSELF ──────────────────────────────────────────────────────────
# 尝试添加或删除注释，观察打印结果
# ═════════════════════════════════════════════════════════════════════════════



# ═════════════════════════════════════════════════════════════════════════════
#   Lesson 04 – 创建 Field（Constant 与 Variable）
# ────────────────────────────────────────────────────────────────────────────
# bites_create_field
bites_create_field := class(creative_device):

    # `Value_1` 与 `Value_2` 都是 Field, Field 是由你自己命名的，可以是任何的名称
    # 下面 2 个 Field 分别代表2种属性, 发现了吗 ? Constant 与 Variable 的差别就在有没有 `var`
    Value_1 : int = 10          # 这是一个 Constant 属性的 Field
    var Value_2 : int = 20      # 这是一个 Variable 属性的 Field
    
    # OnBegin
    OnBegin<override>()<suspends>:void =
        # set Value_1 = 100   # ❌ 会编译错误，因为 Value_1 是 Constant
        Print ("Value_1 = {Value_1}")

        # 使用 set 指令为 Variable 赋新值
        set Value_2 = 200
        Print ("Value_2 = {Value_2}")

    # 更简单的理解, Constant 的参数是固定的无法被修改, Variable 是可以修改的

# ── TRY IT YOURSELF ──────────────────────────────────────────────────────────
# 尝试添加更多 Constant 或 Variable，观察能否修改
# ═════════════════════════════════════════════════════════════════════════════



# ═════════════════════════════════════════════════════════════════════════════
#   Lesson Template – 在 MyBites.verse 中创建一个测试用的通用模板
# ────────────────────────────────────────────────────────────────────────────
# test_generic_template
test_generic_template := class(creative_device):

    @editable BTN_1 : button_device = button_device{}
    @editable BTN_2 : button_device = button_device{}
    @editable BTN_3 : button_device = button_device{}

    # OnBegin
    OnBegin<override>()<suspends>:void =
        BTN_1.InteractedWithEvent.Subscribe( OnBTN_1 )
        BTN_2.InteractedWithEvent.Subscribe( OnBTN_2 )
        BTN_3.InteractedWithEvent.Subscribe( OnBTN_3 )

    # OnBTN_1
    OnBTN_1(Agent:agent):void =
        # 当你还没有建立任何功能的时候，使用 `block:` 替代，否则代码会报错
        block:
            
    # OnBTN_2
    OnBTN_2(Agent:agent):void =
        block:

    # OnBTN_3
    OnBTN_3(Agent:agent):void =
        block:

# ── TRY IT YOURSELF ──────────────────────────────────────────────────────────
# ═════════════════════════════════════════════════════════════════════════════



# ═════════════════════════════════════════════════════════════════════════════
#   Lesson 05 – Common Type - String
# ────────────────────────────────────────────────────────────────────────────
# bites_string
bites_string := class(creative_device):

    @editable BTN_1 : button_device = button_device{}
    @editable BTN_2 : button_device = button_device{}
    @editable BTN_3 : button_device = button_device{}

    # OnBegin
    OnBegin<override>()<suspends>:void =
        BTN_1.InteractedWithEvent.Subscribe( OnBTN_1 )
        BTN_2.InteractedWithEvent.Subscribe( OnBTN_2 )
        BTN_3.InteractedWithEvent.Subscribe( OnBTN_3 )
        
    # 创建 Field, 还记得吗 ? Constant 与 Variable 的差别就在有没有 `var`
    Name : string = "Unreal Rider" 
    var Time : int = 7
    var Day : string = "AM"

    # OnBTN_1
    OnBTN_1(Agent:agent):void =
        # Step_1 : Print 括弧内 "" 输入的 Name 是输入的内容，而不是前面设置的 Field `Name`
        Print ("Step_1 : Name")
        # 在 Print 中使用 {}, 就可以将 Field 的内容打印出来
        Print ("Step_2 : {Name}")                 
        # 因为 Name 已经是 string 类型了，所以可以不一定需要 {} 的方法来输入, 而是直接将它放入 () 中
        Print (Name)
        # 同样的，我们将 `Time` 这个 Field 使用 Print 打印试试
        Print ("Step_4 : {Time}")

    # OnBTN_2
    OnBTN_2(Agent:agent):void =
        # 字符串可以拼接
        Print( Name + " {Time} {Day} 正在学习 Verse" )

    # OnBTN_3
    OnBTN_3(Agent:agent):void =
        # 修改 Variable Field
        set Time = 10
        set Day = "PM"
        Print( Name + " {Time} {Day} 正在学习 Verse" )

# ── TRY IT YOURSELF ──────────────────────────────────────────────────────────
# ═════════════════════════════════════════════════════════════════════════════



# ═════════════════════════════════════════════════════════════════════════════
#  Lesson 06 – Common Type - int、float & Math
# ────────────────────────────────────────────────────────────────────────────
#  目标：了解整数、浮点数与基本算术符号（+ - * /）的用法
# bites_value_and_math
bites_value_and_math := class(creative_device):

    @editable BTN_1 : button_device = button_device{}
    @editable BTN_2 : button_device = button_device{}
    @editable BTN_3 : button_device = button_device{}

    # OnBegin
    OnBegin<override>()<suspends>:void =
        BTN_1.InteractedWithEvent.Subscribe( OnBTN_1 )
        BTN_2.InteractedWithEvent.Subscribe( OnBTN_2 )
        BTN_3.InteractedWithEvent.Subscribe( OnBTN_3 )

    # Value   
    var IntValue_1 : int = 1001          # 可变整数
    IntValue_2 : int = 3                 # 常量整数
    var FloatValue : float = 10.01       # 可变浮点数

    # OnBTN_1
    OnBTN_1(Agent:agent):void =
        # 1. 直接赋值
        set IntValue_1 = 10
        Print ("IntValue_1 Step_1 `SET=10` = {IntValue_1}")
            
    # OnBTN_2
    OnBTN_2(Agent:agent):void =
        # 2. 基本加法
        set IntValue_1 = IntValue_1 + 10
        Print ("IntValue_1 Step_2 `+10` = {IntValue_1}")

        # 3. 复合运算符（推荐使用）
        set IntValue_1 += 10  # 等同于 IntValue_1 = IntValue_1 + 10
        Print ("IntValue Step_3 `+=10` = {IntValue_1}")

        # `+=` `-=` `*=` `/=`
        set IntValue_1 *= 10  # 乘以 10
        Print ("IntValue Step_4 `*=10` = {IntValue_1}")

    # OnBTN_3
    OnBTN_3(Agent:agent):void =
        # 4. 使用括号改变运算顺序
        set IntValue_1 = 20 * ( (7 + 5) - IntValue_2 )
        Print("IntValue_1 Step5 20*( (7+5)-{IntValue_2} ) → {IntValue_1}")

        # set IntValue /= 10      # ⚠️ int 不能使用除法，後面内容将说明如何实现 int 除法
        # set FloatValue /= 20    # ⚠️ float 与 int 不能相除

        # 5. 浮点数除法（必须确保分子或分母带小数点）
        set FloatValue /= 20.0
        Print("FloatValue Step1  /=20.0   → {FloatValue}")

# ⚠️ 注意  
# Verse 中 **判断相等** 使用 `=` ，**赋值** 使用 `set`，两者不要搞混！  

# ── TRY IT YOURSELF ──────────────────────────────────────────────────────────
# ═════════════════════════════════════════════════════════════════════════════



# ═════════════════════════════════════════════════════════════════════════════
#  Lesson 07 – 创建 Field 进阶：可编辑字段
# ────────────────────────────────────────────────────────────────────────────
#  本节延伸 Lesson 04，介绍 @editable 与 var 的组合应用
# bites_create_field_2
bites_create_field_2 := class(creative_device):

    # -------- Field --------
    # 以 "Int_A : int = 5" 为例 :
    #   "Int_A" : 由你创建的一个 Field 名称, "int" 是这个 Field 的类型, "5" 这个 Field 的值
    #   "Int_A" 与 "int" 之间使用 ":", "int" 与 "5" 之间使用 "="
    #   "Int_A : int = 5" 用口语表 : 创建一个名为 "Int_A" 的 Field, Field 的类型是 "int", 并且数值等于 "5"

    # -------- 基本字段 --------
    Int_A : int = 5
    Float_A : float = 10.0
    String_A : string = "Pizza"

    # -------- 可编辑字段 --------
    # @editable 不仅是关联 UEFN Device 的方法
    # 可以让你在 UEFN 细节面板中输入数值，方便关卡设计应用，是不是感觉更像是一个 Device 了!
    @editable Int_B : int = 0
    @editable Float_B : float = 0.0
    @editable String_B : string = ""

    OnBegin<override>()<suspends>:void =
        Print("Int_A + Int_B = {Int_A + Int_B}")
        Print(String_A + " VS " + String_B)

# ── TRY IT YOURSELF ──────────────────────────────────────────────────────────
# 在 UEFN 编辑器里修改 Int_B / Float_B / String_B，修改代码并查看打印变化
# ═════════════════════════════════════════════════════════════════════════════



# ═════════════════════════════════════════════════════════════════════════════
#   Lesson 08 – 控制流程：if / else / then
# ────────────────────────────────────────────────────────────────────────────
#   目标：学习 if 最常用的条件判断写法
# bites_if_basic
bites_if_basic := class(creative_device):

    # Value    
    Value_A : int   = 2 
    var Value_B : float = 10.0 

    # OnBTN_1
    OnBTN_1(Agent:agent):void =
        # 1. 只有 if
        if (Value_A = 1):
            Print("Only if :: Value_A = 1")

        if (Value_A = 2):
            Print("Only if :: Value_A = 2")         # ← 本例会打印这一行

        if (Value_A = 10.0):
            Print("Only if :: Value_A = 10.0")      # ← 不会执行
            
    # OnBTN_2
    OnBTN_2(Agent:agent):void =
        # 2. if … else
        if (Value_A = 2):
            Print("if else :: Value_A = 2 → true")  # ← 本例会打印
        else:
            Print("if else :: Value_A = 2 → false")

    # OnBTN_3
    OnBTN_3(Agent:agent):void =
        # 3. if … else if … else
        if (Value_A = 10.0):
            Print("else if :: Value_A = 10.0")
        else if (Value_A = 4):
            Print("else if :: Value_A = 4")
        else if (Value_A = 2):
            Print("else if :: Value_A = 2")         # ← 本例会打印
        else:
            Print("else if :: All false!!")

    # OnBTN_4
    OnBTN_4(Agent:agent):void =
        # 4. if … then   (多条件 AND 写法)
        if (Value_A = 2, Value_B = 10.0):           # 两个条件同时为 true 才会执行
            Print("if then :: A=2 AND B=10.0 → true")

        # 下面的内容你现在可以知道，但建议现在可以忘记
        # 同功能的区块写法（可读性更高）
        if:
            Value_A = 2
            Value_B = 10.0
        then:
            Print("if then (block) :: A=2 AND B=10.0 → true")

# ── TRY IT YOURSELF ──────────────────────────────────────────────────────────
# 1. 复制整个 bites_if_basic 类到 MyBites.verse，并改名为 bites_if_test
# 2. 修改 Value_A / Value_B 的数值，观察哪些 Print 会出现
# 3. 把其中一段 if … else if … else 的顺序调整，体会执行顺序差异
# 4. 尝试加入 @editable，让 Value_A / Value_B 在 UEFN 细节面板中可调整
# ═════════════════════════════════════════════════════════════════════════════



# ═════════════════════════════════════════════════════════════════════════════
#   Lesson 09 – 比较运算符：<  <=  >  >=  =  <>
# ────────────────────────────────────────────────────────────────────────────
#   目标：学会使用 6 种常见的「比较运算符」
#   ▸ `<`   小于
#   ▸ `<=`  小于或等于
#   ▸ `>`   大于
#   ▸ `>=`  大于或等于
#   ▸ `=`   等于   （⚠️ 判断相等，用 `=`，不是赋值）
#   ▸ `<>`  不等于
# bites_comparison_basic
bites_comparison_basic := class(creative_device):

    # Value
    @editable Value_A : int = 5
    @editable Value_B : int = 3

    # OnBTN_1
    OnBTN_1(Agent:agent):void =
        if (Value_A < Value_B):
            Print("Value_A <  Value_B → true")
        else:
            Print("Value_A <  Value_B → false")   # ← 本例会打印

    # OnBTN_2
    OnBTN_2(Agent:agent):void =
        if (Value_A <= Value_B):
            Print("Value_A <= Value_B → true")
        else:
            Print("Value_A <= Value_B → false")   # ← 本例会打印

    # OnBTN_3
    OnBTN_3(Agent:agent):void =
        if (Value_A = Value_B):
            Print("Value_A  = Value_B → true")
        else:
            Print("Value_A  = Value_B → false")   # ← 本例会打印

    # OnBTN_4
    OnBTN_4(Agent:agent):void =
        if (Value_A <> Value_B):
            Print("Value_A <> Value_B → true")    # ← 本例会打印
        else:
            Print("Value_A <> Value_B → false")

#   可用于类型
#   ───────────────────────────────────────────
#   运算符           支援类型
#   <  <=  >  >=    int, float
#   =  <>           int, float, logic, string, enum

# ── TRY IT YOURSELF ──────────────────────────────────────────────────────────
# ═════════════════════════════════════════════════════════════════════════════



# ═════════════════════════════════════════════════════════════════════════════
#   Lesson 10 – 逻辑决策：or / and 复合条件
# ────────────────────────────────────────────────────────────────────────────
#   目标：使用 `or` 与 `and` 实现「喝魔药 ➜ 施放火球」的决策逻辑
#   ▸ `or`  只要 **任一条件** 成立就执行         （逻辑或）
#   ▸ `and` 必须 **全部条件** 成立才执行         （逻辑与）

# bites_decision_basic
bites_decision_basic := class(creative_device):

    @editable var MyMana : int = 5   # 玩家当前魔力（可在 UEFN 调整）

    # Value
    MaxMana     : int = 20      # 玩家魔力上限
    PotionGain  : int = 10      # 喝药水回复值
    FireCost    : int = 15      # 火球消耗值

    # OnBegin
    OnBegin<override>()<suspends>:void =
        Print("GAME START -- MyMana = {MyMana}")

    # OnBTN_1
    OnBTN_1(Agent:agent):void =
        # or 逻辑：只要其中一条路可行，就提示玩家
        #    A. 现在就能放火球   (MyMana ≥ FireCost)
        #    B. 先喝药也能放火球 (MyMana + PotionGain ≥ FireCost)
        if ((MyMana >= FireCost) or (MyMana + PotionGain >= FireCost)):
            Print("可行方案：直接 Fireball，或 Potion 后再 Fireball")
        else:
            Print("Mana 不足：无论如何都放不了 Fireball")

        Print("End   -- MyMana = {MyMana}")

    # OnBTN_2
    OnBTN_2(Agent:agent):void =
        # and 逻辑：两个条件都满足才执行「喝药 ➜ 放火球」
        #    1) 当前 Mana 未满 (MyMana < MaxMana)
        #    2) 喝药后扣火球，不会溢出且仍 ≥ 0
        if ((MyMana < MaxMana) and (MyMana + PotionGain - FireCost >= 0)):
            # 顺序：先喝药再放火球
            set MyMana += PotionGain
            set MyMana -= FireCost
            Print("Potion ➜ Fireball 成功！剩余 Mana = {MyMana}")
        else:
            Print("Potion ➜ Fireball 失败（条件不足）")

        Print("End   -- MyMana = {MyMana}")

# ── TRY IT YOURSELF ──────────────────────────────────────────────────────────
# ═════════════════════════════════════════════════════════════════════════════



# ═════════════════════════════════════════════════════════════════════════════
#   Lesson 11 – Failable Expressions
# ────────────────────────────────────────────────────────────────────────────
#   目標 ：初步認識 **Failable Expression**（可失敗運算式）這個概念  

# bites_failable_expr_basic
bites_failable_expr_basic := class(creative_device):

    # Value
    MaxMana : int = 20
    var MyMana : int = 5

    # OnBegin
    OnBegin<override>()<suspends>:void =
        # ↓ 這個 if，其實就是一個「可失敗運算式」：
        #    條件成立 → 傳回 true，執行 Print
        #    條件失敗 → 傳回 false，整段不產生值
        if (MyMana >= MaxMana):
            Print("Mana Full!")

# TIPS
# 1. 在 Verse 裏 **所有東西都是表達式**，都會產生一個結果（value）。  
# 2. **Failable Expression** 就是「可能成功、也可能失敗」的表達式：  
#    ‣ 成功 → 產生值　‣ 失敗 → 不產生值（相當於什麼都沒發生）  
# 3. 你可以把它想成魔法師施法時的「安全保險機制」——條件不符就根本不施法，避免爆炸。
# 💡 你現在可以先這樣理解：**Failable Expression ≈ if 條件判斷**

# ── TRY IT YOURSELF ──────────────────────────────────────────────────────────
# ═════════════════════════════════════════════════════════════════════════════



# ═════════════════════════════════════════════════════════════════════════════
#   Lesson 12 – int, float 与 string 的转换
# ────────────────────────────────────────────────────────────────────────────
#   目標:
#   ▸ 把 int 轉成 float（相容運算）  
#   ▸ 把 float 轉成 int（截斷 / 取整）  
#   ▸ 認識 Floor / Ceil / Round 常用取整函式  
#   ▸ 把數值轉成 string（輸出 / 顯示）  

# bites_value_conversion
bites_value_conversion := class(creative_device):

    # Value
    Value_A : int   = 18
    Value_B : float = 54.5

    # OnBegin
    OnBegin<override>()<suspends>:void =
        Print ("Value_A={Value_A}, Value_B={Value_B}")

    # OnBTN_1
    OnBTN_1(Agent:agent):void =
        # 1. int → float
        #    最簡單的方式：乘上 1.0
        NewValue_A : float = Value_A * 1.0
        Print("Value_A = {Value_A}  ➜  NewValue_A = {NewValue_A}")

    # OnBTN_2
    OnBTN_2(Agent:agent):void =
        # 2. float → int
        #    用 Int[ ] 將 float 轉 int（小數點後直接截斷）
        if (NewInt_B := Int[Value_B]):
            Print("Value_B = {Value_B}  ➜  NewInt_B  = {NewInt_B}")

    # OnBTN_3
    OnBTN_3(Agent:agent):void =
        # 3. 其他取整工具
        #    Floor  → 永遠「向下」取整
        #    Ceil   → 永遠「向上」取整
        #    Round  → 四捨五入取整
        if (Floor_B := Floor[Value_B]):
            Print("Floor[Value_B]  = {Floor_B}")   # 54

        if (Ceil_B := Ceil[Value_B]):
            Print("Ceil[Value_B]  = {Ceil_B}")    # 55

        if (Round_C := Round[Value_B]):
            Print("Round[Value_B]  = {Round_C}")   # 6

        if (Round_D := Round[Value_B - 0.2]):
            Print("Round[Value_B - 0.2]  = {Round_D}")   # 5

    # OnBTN_4
    OnBTN_4(Agent:agent):void =
        # 4. Value To String
        # 使用 ToString() 方法
        #    方法 A：先创建一个新的 string 变量，再用 set 指令賦值
        var String_A : string = "123"
        set String_A = ToString(Value_A)

        #    方法 B：使用这种方法的限制是必须使用常量，不能为变量
        String_B := ToString(Value_B)

        Print( "String_A = " + String_A + " String_B = " + String_B )

# ⚠️ 目前 Verse **無法** 把 string 直接轉回 int / float

# ── TRY IT YOURSELF ──────────────────────────────────────────────────────────
# ═════════════════════════════════════════════════════════════════════════════



# ═════════════════════════════════════════════════════════════════════════════
#   Lesson 13 – Common Type：logic
# ────────────────────────────────────────────────────────────────────────────
#   目標:
#   ▸ 認識 `logic` 类型（只有 `true` / `false`）  
#   你可以更简单的理解 logic 就是 ON/OFF (true/flase)
#       ▸ `true`  相當於 **ON**  
#       ▸ `false` 相當於 **OFF**

# bites_logic_basic
bites_logic_basic := class(creative_device):

    # Value
    var LogicFlag : logic = true

    # OnBTN_1
    OnBTN_1(Agent:agent):void =
        # 1. 判断當前狀態
        if (LogicFlag = true):
            Print("LogicFlag is ON")
        else:
            Print("LogicFlag is OFF")          # ← 會打印這行

    # OnBTN_2
    OnBTN_2(Agent:agent):void =
        # 2. 切換狀態（false ➜ true）
        set LogicFlag = true

        if (LogicFlag = true):
            Print("LogicFlag is ON")            # ← 此時會打印 ON
        else:
            Print("LogicFlag is OFF")

    # OnBTN_3
    OnBTN_3(Agent:agent):void =
        # 3. logic 比較運算
        AnotherFlag : logic = false

        # = 　等於
        if (LogicFlag = AnotherFlag):
            Print("兩者相等")
        else:
            Print("兩者不相等")                 # ← 本例會打印

        # <>  不等於
        if (LogicFlag <> AnotherFlag):
            Print("Logic comparison <> 為 true") # ← 本例會打印

# ── TRY IT YOURSELF ──────────────────────────────────────────────────────────
# ═════════════════════════════════════════════════════════════════════════════



# ═════════════════════════════════════════════════════════════════════════════
#   Lesson 14 – Query
# ────────────────────────────────────────────────────────────────────────────
# bites_query
bites_query := class(creative_device):

    # Value
    @editable IsMorning : logic = false     # 用面板切換早/晚

    # OnBegin
    OnBegin<override>()<suspends>:void =
        block:

    # OnBTN_1
    OnBTN_1(Agent:agent):void =
        # 1. 在要查询的 Logic 字段後面加上 `?`
        if (IsMorning?):
            Print("Logic Query : Good Morning!")
        else:
            Print("Logic Query : Good Evening!")

    # OnBTN_2
    OnBTN_2(Agent:agent):void =
        # 2. not + Query
        if (not IsMorning?):
            Print("not Query   : Good Evening!")
        else:
            Print("not Query   : Good Morning!")

    # OnBTN_3
    OnBTN_3(Agent:agent):void =
        # 3. not + 比較
        Value : int = 5
        if (not Value > 20):
            Print("Value NOT > 20")          # ← 本例會打印
        else:
            Print("Value > 20")

# ── TRY IT YOURSELF ──────────────────────────────────────────────────────────
# ═════════════════════════════════════════════════════════════════════════════



# ═════════════════════════════════════════════════════════════════════════════
#   Lesson 15 – Scope
# ────────────────────────────────────────────────────────────────────────────
#   目標
#   ▸ 體會「誰能看見誰」與「誰不能看見誰」  
#   ▸ 4 種常見作用域層級 : Global、Class、Block、Function, 但是我们今天不学这些传统的内容
#   ▸ 我将用更简单粗暴的方式说明 !!! 本小节课程请搭配教学视频学习
#   ▸ 我们将 Scope 比作一个公司的组织

# 〓Layer_1 : 靠在代码最左侧的，就是 Global Scope
# 这是一个名为 CEO 的全局 string field
# 现在你知道了，字段也可以设置在 Class 外部
CEO : string = "(Unreal)"                   # 所有 Layer 都能进入

# 现在你知道了，Function 也可以设置在 Class 外部
Function_Scope_Mobile_Office():void =       # 所有 Layer 都能进入
    # 〓Layer_2 : 这是第2层的 Scope
    SpecialAssistant : string = "(Zoe)"     # 只在此函式内有效
    Print ( "Mobile Office Meeting:" + CEO + SpecialAssistant )

# bites_scope_office_a
bites_scope_office_a := class(creative_device):
    # 〓Layer_2
    Manager : string = "(Ann)"     
    MeetingRoom1 : logic = true
    MeetingRoom2 : logic = true

    # OnBegin
    OnBegin<override>()<suspends>:void =
        # 〓Layer_3 : 这是第3层的 Scope
        Print ("Who will lead the meeting?")
        Function_Scope_Mobile_Office()      # 呼叫 Layer_1 的函式
        Room_1()                            # 呼叫 Layer_2 的函式
        MeetingRoom()                       # 呼叫 Layer_2 的函式

    # Room_1
    Room_1():void =
        Employee_3 : string = "(Jack)"      # 僅此函式可見
        Print ( "Office A-Room1 Meeting:" + CEO + Manager + Employee_3)
        # ⚠️ 看不到 Employee_1 / Customer_1 / Employee_2

    # MeetingRoom
    MeetingRoom():void =
        Customer_1 : string = "(Lily)"
        if (MeetingRoom1?):
            # 〓Layer_4 : 这是第4层的 Scope
            Employee_1 : string = "(Eva)"   # 僅此 if 內有效
            Print ( "Meeting : " + Manager + Employee_1 + Customer_1)
            # ⚠️ 看不到 Customer_2 / Employee_2 （尚未宣告）

        Customer_2 : string = "(Isaac)"
        if (MeetingRoom2?):
            Employee_2 : string = "(Ben)"
            Print ( "Meeting : " + Manager + Employee_2 + Customer_1 + Customer_2)    

# bites_scope_office_b
bites_scope_office_b := class(creative_device):

    Manager : string = "(Peter)"

    # OnBegin
    OnBegin<override>()<suspends>:void =
        Function_Scope_Mobile_Office()      # 呼叫 Layer_1 的函式
        Room_1()
        Room_2()

    # Room_1
    Room_1():void =
        Employee_1 : string = "(Sam)"
        Print ( "Office B-Room1 Meeting:" + CEO + Manager + Employee_1 )     # ⚠️ 看不到 Eva

    # Room_2    
    Room_2():void =
        Employee_2 : string = "(Eva)"
        Print ( "Office B-Room2 Meeting:" + CEO + Manager + Employee_2 )     # ⚠️ 看不到 Sam
        

# ── TRY IT YOURSELF ──────────────────────────────────────────────────────────
# ═════════════════════════════════════════════════════════════════════════════



# ═════════════════════════════════════════════════════════════════════════════
#   Lesson 16 – Functions (1)
# ────────────────────────────────────────────────────────────────────────────
#   目标: 初步认识 Function
# bites_function_1
bites_function_1 := class(creative_device):

    # OnBegin
    OnBegin<override>()<suspends>:void =
        Function_A()
        Function_B()

    # Function_A 
    Function_A():void =
        Print("Function_A is working!")

    # `Function_A` 是方法的名字, 依照设计的场景与需求自己定义合适的命名
    # 建立一个方法需要 `方法名字` + `()` + `:` + `void` + `=`, 结果就是 `Function_A():void=`
    # 初学最好的方法，直接 Copy `Function_A():void=` 然后重新命名 `Function_A`
    # `()` 括好内可以设置方法需要的参数, 并在方法中使用这些参数，现在是空的，表示这个方法不需要任何的参数代入就可以执行
    # `void` 代表这个参数不会返回任何的参数, 在学习 Lesson 19 之前，我们就保持使用 void 就可以了

    # Function_B 
    Function_B():void =
        Print("Function_B is working!")

    # 命名建议: 
    #   Class : 所以字母一律小写，到後面的课程你就会明白为什么
    #   Function : 采用每个字的开头字母大写

# ── TRY IT YOURSELF ──────────────────────────────────────────────────────────
# ═════════════════════════════════════════════════════════════════════════════



# ═════════════════════════════════════════════════════════════════════════════
#   Lesson 17 – Functions (2)
# ────────────────────────────────────────────────────────────────────────────
#   目标: 创建 Function 来改变现有的变数
# bites_function_2
bites_function_2 := class(creative_device):

    # 在引用的 UEFN 装置命名时，推荐使用`大写缩写` + `_` 的格式
    @editable BTN_AddMana : button_device = button_device{}
    @editable BTN_SubMana : button_device = button_device{}

    # Value
    var MyMana : int = 10   # 当前魔力
    AddMana : int = 5
    SubMana : int = -5

    # OnBegin
    OnBegin<override>()<suspends>:void =
        Print("游戏开始，初始魔力为：{MyMana}")
        BTN_AddMana.InteractedWithEvent.Subscribe(OnAddMana)
        BTN_SubMana.InteractedWithEvent.Subscribe(OnSubMana)

    # OnAddMana 
    OnAddMana(Agent:agent):void =
        # 对 MyMana 使用 set 命令来增加 AddMana
        set MyMana += AddMana
        Print("MyMana = {MyMana}")

    # OnSubMana 
    OnSubMana(Agent:agent):void =
        # 对 MyMana 使用 set 命令来增加 SubMana
            # 因 SubMana 是负数，所以最后的结果将是减法
        set MyMana += SubMana
        Print("MyMana = {MyMana}")

    # ▼▼▼ 执行流程解析 (当按下 BTN_AddMana)
    # 1. 玩家按下按钮，触发 InteractedWithEvent 事件。
    # 2. OnBegin 中的 Subscribe 让系统直接呼叫 OnAddMana(Agent:agent) 函式。
    # 3. 函式内部执行 `set MyMana += AddMana`，MyMana 从 10 变为 15 (10 + 5)。
    # 4. Print 函式在日志中印出结果："MyMana = 15"。

    # ▼▼▼ 思考一下...
    # 你是否注意到 OnAddMana 和 OnSubMana 这两个函式内部的程式码结构几乎完全一样？
    # 它们都修改了 MyMana，然后都 Print 出来。这种程式码的「重复」是我们要尽量避免的。
    # 在下一课，我们将学习如何用「函式参数」来解决这个问题，让程式码更简洁、更强大！

# ── TRY IT YOURSELF ──────────────────────────────────────────────────────────
# ═════════════════════════════════════════════════════════════════════════════



# ═════════════════════════════════════════════════════════════════════════════
#   Lesson 18 – Functions (3)
# ────────────────────────────────────────────────────────────────────────────
#   目标: 创建可输入参数的 Function
# bites_function_3
bites_function_3 := class(creative_device):

    @editable BTN_AddMana : button_device = button_device{}
    @editable BTN_SubMana : button_device = button_device{}

    # Value
    var MyMana  : int = 10
    AddMana   : int = 5
    SubMana   : int = -5

    # OnBegin
    OnBegin<override>()<suspends>:void =
        PrintInitValues(AddMana, SubMana)
        BTN_AddMana.InteractedWithEvent.Subscribe(OnAddMana)
        BTN_SubMana.InteractedWithEvent.Subscribe(OnSubMana)

    # PrintInitValues 
    PrintInitValues(AddValue:int, SubValue:int):void =
        Print("AddMana = {AddValue}, SubMana = {SubValue}")

    # 创建一个名为 `HandleManaEvent` 的方法
        # 在 () 内设置这个函式需要接收的参数(Parameter)
        # 格式为 `Field`:`Type`，例如: (ID:int)、(Health:float)、(Name:string)
        # 这个 Field 只会在 Function 中的作用域生效, 同样不能与上层作用域的命名重复
    # HandleManaEvent 
    HandleManaEvent(Delta:int):void =   # 这里设置了一个名为 Delta 的 Field，类型是 int 
        set MyMana += Delta             # 当方法执行的时候，MyMana 就会加上 Delta 所被赋予的 int 参数
        Print("MyMana = {MyMana}")


    # 当我們订阅按钮 InteractedWithEvent 时, API 要求對應的 Function 必須能接收一個 agent 類型的參數。
        # 如何识别每个功能需要输入什么样的参数? 我们会在 Lesson - 21 学习到
        # 在当前案例中，我们还不会使用到 agent
    # `agent` 是一个代理，通常指與裝置互動的玩家或 NPC, 而 `Agent` 就是自定义的 Field，所以你可以尝试修改 Agent 的命名，但你一定修改 agent 就会报错
    # OnAddMana 
    OnAddMana(Agent:agent):void =  
        HandleManaEvent(AddMana)   

    # OnSubMana 
    OnSubMana(Agent:agent):void =
        HandleManaEvent(SubMana)

    # ▼▼▼ 执行流程解析 (当按下 BTN_AddMana)
    # 1. 玩家按下按钮，因为 OnBegin 中的 Subscribe 设置，系统自动呼叫 OnAddMana 函式。
    # 2. OnAddMana 函式接着呼叫 HandleManaEvent(AddMana)，并将 AddMana 的值 (也就是 5), 作为「引数 (Argument)」传递过去。
    # 3. 在 HandleManaEvent(Delta:int) 中，名为 Delta 的「参数 (Parameter)」接收到值 5。
    # 4. 执行 `set MyMana += Delta`，使得 MyMana 从 10 变为 15 (10 + 5)。
    # 5. 最后 Print 函式在日志中印出结果："MyMana = 15"。

# ── TRY IT YOURSELF ──────────────────────────────────────────────────────────
# ═════════════════════════════════════════════════════════════════════════════



# ═════════════════════════════════════════════════════════════════════════════
#   Lesson 19 – Functions (4)
# ────────────────────────────────────────────────────────────────────────────
#   目标 : 创建可 Return 参数的 Function, 这次我们要对 void 动手了!!!
# bites_function_return
bites_function_return := class(creative_device):

    @editable BTN_AddMana : button_device = button_device{}
    @editable BTN_SubMana : button_device = button_device{}

    # Value
    var MyMana  : int = 10
    AddMana : int = 5 
    SubMana   : int = -5   # 减少量

    # OnBegin
    OnBegin<override>()<suspends>:void =
        BTN_AddMana.InteractedWithEvent.Subscribe(OnAddMana)
        BTN_SubMana.InteractedWithEvent.Subscribe(OnSubMana)

    # OnAddMana 
    OnAddMana(Agent:agent):void =
        # ResultValue : int = HandleManaEvent(AddMana)
        ResultValue := HandleManaEvent(AddMana)
        Print ("MyMana = {ResultValue}")

        NoMana := CheckMana(ResultValue)
        if (NoMana?):
            Print ("MyMana < 0")

    # OnSubMana 
    OnSubMana(Agent:agent):void =
        ResultValue := HandleManaEvent(SubMana)
        Print ("MyMana = {ResultValue}")

        NoMana := CheckMana(ResultValue)
        if (NoMana?):
            Print ("MyMana < 0")

    # HandleManaEvent (return int) 
    HandleManaEvent(Delta:int):int =
        set MyMana += Delta
        return MyMana

    # CheckMana (return logic) 
    CheckMana(Value:int):logic=   
        if (Value < 0):
            return true
        else:
            return false

# ── TRY IT YOURSELF ──────────────────────────────────────────────────────────
# ═════════════════════════════════════════════════════════════════════════════

